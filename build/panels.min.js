(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.webit || (g.webit = {})).panels = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var b = function(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    var cx = 3.0 * p1x;
    var bx = 3.0 * (p2x - p1x) - cx;
    var ax = 1.0 - cx -bx;
         
    var cy = 3.0 * p1y;
    var by = 3.0 * (p2y - p1y) - cy;
    var ay = 1.0 - cy - by;

    var epsilon = 0.00001;

    function sampleCurveDerivativeX(t) {
        return (3.0 * ax * t + 2.0 * bx) * t + cx;
    }

    function sampleCurveX(t) {
        // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
        return ((ax * t + bx) * t + cx) * t;
    }

    function sampleCurveY(t) {
        return ((ay * t + by) * t + cy) * t;
    }

    // Given an x value, find a parametric value it came from.
    function solveCurveX(x)
    {
        var t0, t1, t2, x2, d2, i;

        // First try a few iterations of Newton's method -- normally very fast.
        for (t2 = x, i = 0; i < 8; i++) {
            x2 = sampleCurveX(t2) - x;
            if (Math.abs(x2) < epsilon) {
                return t2;
            }
            d2 = sampleCurveDerivativeX(t2);
            if (Math.abs(d2) < 1e-6) {
                break;
            }
            t2 = t2 - x2 / d2;
        }

        // Fall back to the bisection method for reliability.
        t0 = 0.0;
        t1 = 1.0;
        t2 = x;

        if (t2 < t0) {
            return t0;
        }
        if (t2 > t1) {
            return t1;
        }

        while (t0 < t1) {
            x2 = sampleCurveX(t2);
            if (Math.abs(x2 - x) < epsilon) {
                return t2;
            }
            if (x > x2) {
                t0 = t2;
            }
            else {
                t1 = t2;
            }
            t2 = (t1 - t0) * .5 + t0;
        }

        // Failure.
        return t2;
    }

    this.get = function(x) {
        return sampleCurveY(solveCurveX(x));
    }
}

module.exports = b;
},{}],2:[function(require,module,exports){
//var Bezier = require('./bezier1.js');
var Bezier = require('./bezier2.js');

var Stepper = function() {
    this.defaultBezierCurve = [0,0,1,1];
    this.precision = 10000000;
    this.progress = 0;
    this.current = 0;
    this.requestId = 0;
    this.inProgress = false;
}

Stepper.prototype = {
    run: function(duration, bezierCurve, stepCb, doneCb, forceStopCb) {
        this.stepCallback = stepCb;
        this.doneCallback = doneCb;
        this.forceStopCallback = forceStopCb;

        this.easing = this.getEasing(bezierCurve);

        this.duration = isNaN(duration) ? 0 : duration;
        this.current = 0;

        this.start();
        this.step();
    },

    /**
     * Run from given progress
     */
    runFrom: function(progress, duration, bezierCurve, stepCb, doneCb) {
        this.stepCallback = stepCb;
        this.doneCallback = doneCb

        this.easing = this.getEasing(bezierCurve);

        /**
         * Šeit ir svarīgs moments
         * Padotais progress ir tāds, kādu gribam
         * bet easing aprēķinātais progress esošajā progress ir savādāk, jo 
         * tas ir curve un tas nav lineārs
         * Tāpēc šeit atrodam kādam ir jābūt progresam pēc easing
         */
        progress = this.findStartProgress(progress, 0.1, 0, 1);
        
        this.duration = duration;

        this.startTime = +new Date();
        // Simulējam startTime, tā lai tas būtu sācies pirms norādītā progress
        this.startTime -= (duration * progress);
        // Turpinām no padotā progress
        this.progress = progress;

        this.inProgress = true;


        this.step();
    },

    /**
     * Meklējam kādam ir jābūt progress, lai pēc easing.get tas būt tāds pats kā progress
     */
    findStartProgress: function(progress, step, from, to, inceptionLevel) {

        if (typeof inceptionLevel == 'undefined') {
            inceptionLevel = 0;
        }
        
        var d = from, prevR = 0, prevD;

        while (d < to) {
            // Lai ir lielāka precizītāte
            if (inceptionLevel++ > 40) {
                return d;
            }

            r = this.easing.get(d);

            if (Math.round(progress*this.precision) == Math.round(r*this.precision)) {
                return d;
            }

            if (this.isBetween(progress, prevR, r)) {
                return this.findStartProgress(progress, step/10, prevD, d, inceptionLevel);
            }

            prevD = d;
            prevR = r;
            d += step;
        }

        return d;
    },

    /**
     * Is a between x1 and x2
     */
    isBetween: function(a, x1, x2) {
        if (x2 > x1) {
            return a > x1 && a < x2;
        }
        return a > x2 && a < x1;
    },

    isRunning: function() {
        return this.inProgress;
    },

    /**
     * Piefiksējam sākuma laiku
     */
    start: function() {
        this.inProgress = true;
        this.startTime = +new Date();
        this.progress = 0;
    },

    /**
     * Pārtraucam stepping
     */
    stop: function() {
        cancelAnimationFrame(this.requestId);
        this.done();
    },

    /**
     * Pārtraucam animāciju un neizpildām done callback
     */
    forceStop: function() {
        cancelAnimationFrame(this.requestId);
        this.inProgress = false;
        if (this.forceStopCallback) {
            this.forceStopCallback();
        }
    },

    done: function() {
        this.inProgress = false;
        if (this.doneCallback) {
            this.doneCallback();
        }
    },

    step: function() {
        var mthis = this;


        // if (this._prevTime) {
        //     log('stepper.step', Math.round(window.performance.now() - this._prevTime));
        // }
        // this._prevTime = window.performance.now();


        mthis.trackProgress();

        if (this.current < this.startTime + this.duration) {

            this.stepCallback(this.progress);

            this.requestId = requestAnimationFrame(function(){
                mthis.step()
            });
        }
        else {
            this.stepCallback(1);

            this.done();
        }
    },

    trackProgress: function() {
        // Current time
        this.current = +new Date();

        var delta = this.current - this.startTime;

        // Animation progress in precents
        this.progress = this.easing.get(delta / this.duration);

        //this.progress = Math.round(this.progress*this.precision)/this.precision;
    },

    getEasing: function(bezierCurve) {
        if (!(bezierCurve && bezierCurve.length && bezierCurve.length == 4)) {
            bezierCurve = this.defaultBezierCurve;
        }
        return new Bezier(bezierCurve[0], bezierCurve[1], bezierCurve[2], bezierCurve[3]);
    }
}

module.exports = Stepper;
},{"./bezier2.js":1}],3:[function(require,module,exports){
(function(root, factory){

    if (typeof exports === 'object') {
        module.exports = factory();
    }
    else {
        if (typeof root.webit == 'undefined') {
            root.webit = {}
        }
        root.webit.swipe = factory();
    }

})(this, function(){

    var instances = 0;

    var List = function(items) {
        this.items = items;
    }
    List.prototype = {
        first: function() {
            if (this.items.length > 0) {
                return this.items[0];
            }
            return false;
        },
        second: function() {
            if (this.items.length > 1) {
                return this.items[1];
            }
            return false;
        }
    }

    var Swipe = function(el, config) {
        this.instanceId = instances++;


        // Touch/mouse events will be attaches to body
        this.swipeEl = document.getElementsByTagName('body')[0];

        this.el = el;

        this.events = this.prepareEvents([
            'swipe', 'move', 'start', 'end', 
            'pinchstart', 'pinchend', 'pinchmove', 
            'touchend', 'touchmove',
            'tap', 'doubletap'
        ]);

        // Apply configuration
        this.config(config);

        this.setTouchAction(this._config.direction);

        // Visi reģistrētie touchi, pēc to identifikatoriem
        this.touches = {};
        // Piereģistrēto touch skaits
        this.touchesCount = 0;
        // Slope factor to distinguise vertical swipe from horizontal
        this.slopeFactor = 1;
        // First touch when touch start occures
        this.startTouches = false;
        // First touch when first move event triggered
        this.firstMoveTouches = false;
        // Current touch, when swipe is in process
        this.currentTouches = false;

        // Swipe width
        this.width;
        // Swipe height
        this.height;
        // Swipe duration
        this.duration;
        // In case of directional swipe, this will be initial swipe direction (horizontal or vertical)
        this.moveDirection = null;

        // Cik pēdējās swipe kustības uzkrāt, lai noteiktu vai ir bijis swipe
        this.swipeLogStackMaxLength = 4;

        this.swipeLog = {
            stack: [],
            duration: 0,
            width: 0,
            height: 0
        };

        /**
         * Taps logs. Katram touch eventam piereģistrējam sākuma un beigu laiku
         * Pēc tam analizējam taps ilgumu un meklējam starp tiem tap vai double Tap
         * 
         * Reģistrējot pārbaudam vai events ar norādīt id ir reģistrēts. Ja nav tad liekam iekšā
         * un piereģistrējam ienākšanas laiku
         * 
         * Atreģistrējot meklējam eventu, kuram nav endTime
         */
        this.tapsLog = {};
        this.waitForDoubleTap = false;
        this.tapsLogExecuteTimeout = 0;

        /**
         * Is touch events supported
         * This will be determined when first touchstart event fires
         */
        this.isTouchEvents = false;

        /**
         * Is touch started on this.el
         */
        this.isTouchedValidElement = false;

        // Mouse down event
        this.isMouseDown = undefined;

        this.handleEvents('add');

        return this;
    }

    Swipe.prototype = {
        prepareEvents: function(eventNames) {
            var r = {};
            for ( var i in eventNames ) {
                r[eventNames[i]] = [];
            }
            return r;
        },

        handleEvents: function(method) {
            var mthis = this;

            var start = function(ev) {
                // Reģistrēti tiek tikai tie touchi, kuri nāk no iekonfigurētā elementa
                mthis.registerTouches(ev, true);

                mthis.isTouchedValidElement = mthis.touchesCount > 0;
                if (mthis.isTouchedValidElement) {
                    mthis._start(ev);
                }
            }
            
            var end = function(ev) {
                if (mthis.isTouchedValidElement) {
                    mthis._end(ev);
                    mthis.isTouchedValidElement = false;
                }

                mthis.unregisterTouches(ev);

                // Pārbaudām vai var palaist tap vai double tap eventus
                mthis.maybeFireTapping();
            }

            /**
             * @param touchedElement is used only on case of mouse
             * it provides custom element, not the one from current touch
             */
            var move = function(ev) {
                mthis.registerTouches(ev);

                if (mthis.isTouchedValidElement) {
                    mthis._move(ev);
                }
            }

            
            // Ja izpildīsies touchstart, tad mouse eventus vairāk neklausāmies
            var touchStart = function(ev) {
                mthis.isTouchEvents = true;
                start(ev);
            }

            var touchEnd = function(ev) {
                end(ev);
            }

            var touchMove = function(ev) {
                move(ev)
            }


            // Ja ir toucheventi, tad mouse eventus neizpildām
            var _mouseMove;

            var isMouseMove = function(startEv, moveEv) {
                if (startEv.x != moveEv.x) {
                    return true;
                }

                if (startEv.y != moveEv.y) {
                    return true;
                }

                return false;
            }

            var mouseStart = function(ev) {
                mthis.isMouseDown = mthis.formatTouch(ev);

                if (!mthis.isTouchEvents) {
                    start(ev)   
                }
            }

            var mouseEnd = function(ev) {
                if (!mthis.isTouchEvents) {
                    end(ev) 
                }
                mthis.isMouseDown = undefined;
            }

            var mouseMove = function(ev) {
                if (!mthis.isTouchEvents) {
                    if (mthis.isMouseDown) {
                        if (isMouseMove(mthis.isMouseDown, mthis.formatTouch(ev))) {
                            move(ev)
                        }
                    }
                }
            }

            var eventMethod = method == 'add' ? 'addEvent' : 'removeEvent';

            this[eventMethod](this.swipeEl, 'touchstart', touchStart);
            this[eventMethod](this.swipeEl, 'touchmove', touchMove, {passive: false});
            this[eventMethod](this.swipeEl, 'touchend', touchEnd);
        
            this[eventMethod](this.swipeEl, 'mousedown', mouseStart);
            this[eventMethod](this.swipeEl, 'mousemove', mouseMove);
            this[eventMethod](this.swipeEl, 'mouseup', mouseEnd);
        },

        /**
         * Touch start. When touch starts or when mouse down
         */
        _start: function(ev) {

            if (this._config.alwaysPreventTouchStart) {
                this.preventEvent(ev);
            }

            // Touch stāvoklis pašā sākumā
            this.startTouches = this.getTouches();

            // Touch stāvoklis, kad notika pirmais touchMove
            this.firstMoveTouches = false;

            this.validMove = false;
            this.moveDirection = null;
            this.swipeLog.stack = [];

            this.fire('start', [this.startTouches.first()]);

            // retranslate pinch
            this.maybeFirePinchStart();
        },

        /**
         * Touch ends
         */
        _end: function(ev) {
            this.currentTouches = this.getTouches();

            this.trackDuration();
            this.trackSwipe();

            var movement = this.formatMovement();

            // Liekam swipe statusu
            movement._swipeLog = {
                duration: this.swipeLog.duration,
                width: this.swipeLog.width,
                height: this.swipeLog.height,
                stackLength: this.swipeLog.stack.lenght,
                isSwipe: false
            };
            
            /**
             * Šeit pēc duration, width un height nosakām vai tā varēja
             * būt swipe kustība. Varbūt atkarībā no iekārtas varētu šo 
             * parametrus piekoriģēt???
             */
            if (this.swipeLog.duration < 80) {
                if (this.swipeLog.width > 7 || this.swipeLog.height > 7) {
                    movement._swipeLog.isSwipe = true;
                }
            }

            // Pazīme, vai bija swipe kustība
            movement.isSwipe = movement._swipeLog.isSwipe;


            this.startTouches = false;
            this.firstMoveTouches = false;

            if (this.validMove) {
                this.fire("end", [movement]);
             }

            // Vienmēr izpildām touchend eventu
            this.fire("touchend", [movement]);

            // retranslate pinch
            this.maybeFirePinchEnd();
        },

        /**
         * Touch is moving. Moving when mouse down
         */
        _move: function(ev) {

            if (this.startTouches) {

                // If configured to disable pinch to zoom
                this.maybePreventPinch(ev);

                if (!this.firstMoveTouches) {
                    this.firstMoveTouches = this.getTouches();
                }

                this.currentTouches = this.getTouches();

                this.clearTapLog();
                this.trackDuration();
                this.trackSwipe();
                this.trackMovment();

                // Always retranslate touchmove if there was move
                this.fireTouchMove();

                if (this.isValidMove()) {
                    this.preventEvent(ev);
                    this.validMove = true;
                }
                else {
                    this.validMove = false;   
                }
                
                if (this.validMove) {
                    this.fire('move', [this.formatMovement()])
                }

                // retranslate pinch
                this.maybeFirePinchMove();
            }
        },

        /**
         * Pārbaudām vai var palaist tap vai doubletap eventus
         */
        maybeFireTapping: function() {
            clearTimeout(this.tapsLogExecuteTimeout);

            if (this.isEventsRegistered('doubletap')) {
                this.maybeFireDoubleTap(this.getValidTapRegistered());
            }
            else {
                this.maybeFireSingleTap(this.getValidTapRegistered());
            }

            this.clearTapLog();            
        },

        maybeFireDoubleTap: function(tap) {
            if (!tap) {
                return;
            }

            var mthis = this;

            if (this.waitForDoubleTap) {
                this.fire('doubletap', [tap.touch])
                this.waitForDoubleTap = false;
            }
            else {
                // Gaidām nākošo tap
                this.waitForDoubleTap = true;
                this.tapsLogExecuteTimeout = setTimeout((function(touch){
                    
                    return function() {
                        mthis.waitForDoubleTap = false;

                        mthis.fire('tap', [touch])
                    }

                })(tap.touch), this._config.doubletapWaitTimeout)


                /**
                 * @todo Te vajadzētu kaut kādu pseido little bit before tap, jo
                 * uz ios doubletapWaitTimeout ir tāds pats kā šeit iekonfigurēts
                 * bet single tap tomēr izpildās drusku ātrāk. Tas tāpēc, lai interfeiss
                 * justos atsaucīgāks. Savukārt ļoti īsu doubletapWaitTimeout nevar taisīt,
                 * jo kādam, kuram nav veikli pirksti būs grūti uztaisīt doubleTap
                 */
            }
        },

        maybeFireSingleTap: function(tap) {
            if (!tap) {
                return;
            }

            this.fire('tap', [tap.touch])
        },

        maybePreventPinch: function(ev) {
            if (this._config.disablePinch && this.touchesCount >= 2) {
                ev.preventDefault();
            }
        },

        maybeFirePinchStart: function() {
            if (this.touchesCount < 2) {
                return;
            }

            this.fire('pinchstart', [this.formatPinch(
                this.startTouches.first().x,
                this.startTouches.second().x,
                this.startTouches.first().y,
                this.startTouches.second().y
            )]);
        },

        maybeFirePinchEnd: function() {
            if (this.touchesCount < 2) {
                this.fire('pinchend', []);
            }
        },

        maybeFirePinchMove: function() {
            if (this.touchesCount < 2) {
                return;
            }

            // Pinch gadījumā interesē tikai 2 currentTouches
            this.fire('pinchmove', [{
                first: this.formatPinch(
                    this.firstMoveTouches.first().x,
                    this.firstMoveTouches.second().x,
                    this.firstMoveTouches.first().y,
                    this.firstMoveTouches.second().y
                ),
                current: this.formatPinch(
                    this.currentTouches.first().x,
                    this.currentTouches.second().x,
                    this.currentTouches.first().y,
                    this.currentTouches.second().y
                )
            }])
        },

        formatPinch: function(x1, x2, y1, y2) {
            return {
                // Pirmais touch punkts
                x1: x1,
                y1: y1,

                // Otrais touch punkts
                x2: x2,
                y2: y2,

                width: Math.abs(x1-x2),
                height: Math.abs(y1-y2),

                // Atālums starp touchiem. Hipotenūza, kur width un height ir taisnleņķa katetes
                // Aprēķinām pēc pitagora teorēmas distance = sqrt(pow(width, 2) + pow(height, 2))
                distance: Math.sqrt(Math.pow(Math.abs(x1-x2), 2) + Math.pow(Math.abs(y1-y2), 2)),

                // Pinch centrs
                center: {
                    x: this.calcMid(x1, x2),
                    y: this.calcMid(y1, y2)
                }
            }
        },

        calcMid: function(p1, p2) {
            return p1 < p2 ? (p2-p1)/2+p1 : (p1-p2)/2+p2;
        },

        formatMovement: function() {
            return {
                // Padodam konfigurācijai atbilstošu direction. Ja ir iekonfigurēts horizontal, tad padodam left or right
                direction: this.getFormattedDirection(),
                offset: this.offset,
                duration: this.duration,
                width: this.width,
                height: this.height,
                x: this.currentTouches.first().x,
                y: this.currentTouches.first().y,
                touchedElement: this.currentTouches.first().touchedElement,

                speed: this.width / this.duration,
                realDirection: this.direction
            }
        },

        getFormattedDirection: function() {
            if (this.isDirection(this._config.direction, 'horizontal') || this.isDirection(this._config.direction, 'vertical')) {
                return this.getDirection();
            }
            else if (this.isDirection(this._config.direction, 'horizontal')) {
                return this.getHorizontalDirection();
            }
            else if (this.isDirection(this._config.direction, 'vertical')) {
                return this.getHorizontalDirection();
            }
        },

        /** 
         * There we can filter if current move is valid
         * For, example, if we track only horizontal move, then ignore
         * vertical move.
         * There also can be checked, if user is scrolling page
         */
        isValidMove: function() {
            // Ja swipeLog nav pilns, tad nevaram vēl validēt move
            if (this.swipeLog.stack.length < 2) {
                return false;
            }

            /**
             * Ja ir directional swipe, tad ja ir nodetektēts direction
             * atbilstošs swipe, vairāk to nepārtraucam. Jo swipe laikā
             * var mainīties direction, no left kļūt par top
             */
            
            // Swipe direction
            if (this._config.direction.length > 0) {
                
                // Uzstādām pirmo detektēto swipe virzienu
                if (!this.moveDirection) {
                    this.moveDirection = this.getMoveDirection();
                }

                if (!this.isDirection(this._config.direction, this.moveDirection)) {
                    return false;
                }
            }

            var minMaping = {minWidth: 'width', minHeight: 'height', minDuration: 'duration'};
            var maxMaping = {maxWidth: 'width', maxHeight: 'height', maxDuration: 'duration'};

            for (var p in minMaping) {
                if (this._config[p]) {
                    if (this[minMaping[p]] < this._config[p]) {
                        return false;
                    }    
                }
                
            }

            for (var p in maxMaping) {
                if (this._config[p]) {
                    if (this[maxMaping[p]] > this._config[p]) {
                        return false;
                    }
                }
            }

            return true;
        },

        /**
         * Track swipe progress. Calculates swipe width, height and duration
         */
        trackMovment: function() {
            this.offset = {
                x: this.currentTouches.first().x - this.firstMoveTouches.first().x,
                y: this.currentTouches.first().y - this.firstMoveTouches.first().y
            };
            this.width = Math.abs(this.offset.x);
            this.height = Math.abs(this.offset.y);
            
            this.direction = this.getDirection();
        },

        trackDuration: function() {
            this.duration = this.currentTouches.first().t - this.startTouches.first().t;
        },

        trackSwipe: function() {
            // Uzkrājam pēdējās this.swipeLogStackMaxLength move kustības. No tām tiks noteikts vai ir bijis swipe
            this.swipeLog.stack.push({
                x: this.currentTouches.first().x,
                y: this.currentTouches.first().y,
                duration: this.duration
            });

            if (this.swipeLog.stack.length > this.swipeLogStackMaxLength) {
                this.swipeLog.stack.shift();
            }

            // Time between first and last logged movement
            this.swipeLog.duration = this.swipeLog.stack[this.swipeLog.stack.length-1].duration - this.swipeLog.stack[0].duration;
            this.swipeLog.width = Math.abs(this.swipeLog.stack[this.swipeLog.stack.length-1].x - this.swipeLog.stack[0].x);
            this.swipeLog.height = Math.abs(this.swipeLog.stack[this.swipeLog.stack.length-1].y - this.swipeLog.stack[0].y);
        },

        /**
         * Atgriežam virzienu vienalga kādā virzienā. Vai horizontal vai vertical.
         * Pirmo pārbaudām vertikālo virzienu. Ja tā nav, tad horizontālo
         */
        getDirection: function() {
            if (this.getVerticalDirection()) {
                return this.getVerticalDirection();
            }
            else if (this.getHorizontalDirection()) {
                return this.getHorizontalDirection();
            }
        },

        /**
         * Atgriežam tikai horizontālo virzienu: left or right
         */
        getHorizontalDirection: function() {
            if (this.currentTouches.first().x > this.startTouches.first().x) {
                return "right";
            }
            else if (this.currentTouches.first().x < this.startTouches.first().x) {
                return "left";
            }

            return false;
        },

        /**
         * Atgriežam tikai vertikālo virzienu: up or down
         */
        getVerticalDirection: function() {
            /**
             * Horizontal swipe elevation
             * When swiping left right there van be slight elveation, but this
             * does not mean user is swiping up or down
             */
            if (this.offset) {
                var e = this.offset.y / this.offset.x;

                if (e > this.slopeFactor) {
                    return "up";
                }
                else if (e < -this.slopeFactor) {
                    return "down";
                }
            }

            return false;
        },

        getMoveDirection: function() {
            if (this.isHorizontalDirection()) {
                return 'horizontal';
            }
            
            if (this.isVerticalDirection()) {
                return 'vertical';
            }

            return '';
        },

        isHorizontalDirection: function() {
            return (this.direction == "left" || this.direction == "right");
        },

        isVerticalDirection: function() {
            return (this.direction == "up" || this.direction == "down");
        },

        /**
         * Apstrādājam touch registered notikumu
         */
        handleTouchRegistered: function(touch) {
            this.touchesCount++;

            // Ja ir viens touch, tad reģistrējam kā tap
            if (this.touchesCount == 1) {
                // Reģistrējam tap
                this.registerTapLog(this.touches[touch.identifier]);
            }
        },

        handleTouchUnregistered: function(identifier) {
            this.touchesCount--;

            // Atreģistrējam tap
            this.unregisterTapLog(identifier);
        },

        /**
         * @param validateTouchedElement Reģistrējam tikai tos touch, kuri nāk no iekonfigurētā elementa
         * Tas ir vajadzīgs, lai swipe sāktos tikai uz iekofigurēto elementu
         * Pēc tam, kad notiek move, tad neskatamies uz touched elementu
         *
         * changedTouches nesatur to elementu uz kura tagad touch atrodas
         * elements vienmēr būs tas no kura sākās touch events
         * Elements, kurš pašlaik ir zem touch jānosaka ar pageX pageY vai kaut kā savādāk
         */
        registerTouches: function(ev, validateTouchedElement) {
            if (ev.changedTouches) {
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    this.registerTouch(this.formatTouch(ev.changedTouches[i]), this.eventTarget(ev.changedTouches[i]), validateTouchedElement);
                }
            }
            else {
                this.registerTouch(this.formatTouch(ev), this.eventTarget(ev), validateTouchedElement);
            }
        },

        unregisterTouches: function(ev) {
            if (ev.changedTouches) {
                for (var i = 0; i < ev.changedTouches.length; i++) {
                    this.unregisterTouch(ev.changedTouches[i].identifier)
                }
            }
            else {
                this.unregisterTouch('_faketouch')
            }
        },

        registerTouch: function(touch, touchedElement, validateTouchedElement) {

            if (validateTouchedElement) {
                if (!this.isTheElement(touchedElement)) {
                    return false;
                }
            }
            
            // Update
            if (this.isTouchRegistered(touch)) {
                this.touches[touch.identifier] = touch;
                this.touches[touch.identifier].touchedElement = touchedElement;

                return false;
            }

            // Insert new
            this.touches[touch.identifier] = touch;
            this.touches[touch.identifier].touchedElement = touchedElement;

            // Touch ir piereģistrēts
            this.handleTouchRegistered(this.touches[touch.identifier]);
        },

        unregisterTouch: function(identifier) {

            if (typeof this.touches[identifier] != 'undefined') {
                delete this.touches[identifier];

                // Paziņojam, ka touch ir atreģistrēts
                this.handleTouchUnregistered(identifier);
            }
        },

        isTouchRegistered: function(touch) {
            return (typeof this.touches[touch.identifier] != 'undefined');
        },

        /**
         * Get touch object from event
         * We need only x, y coordinates and time of touch
         */
        // getTouch: function(ev) {
        //     var t = false;
        //     var changedTouches = ev.changedTouches;
            
        //     if (changedTouches) {
        //         t = changedTouches[0];
        //     }
        //     else {
        //         t = ev;
        //     }
            
        //     t = t ? this.formatTouch(t) : false;

        //     if (t) {
        //         // Pieglabājam elementu, uz kura notika touch
        //         t.touchedElement = this.eventTarget(ev);
        //     }

        //     return t;
        // },

        /**
         * Atgriežam touches kopiju uz doto mirkli
         */
        getTouches: function() {
            var mthis = this;
            return new List(this.map(this.touches, function(touch){
                return mthis.clone(touch);
            }))
        },

        formatTouch: function(ev) {
            return {
                identifier: (typeof ev.identifier == 'undefined' ? '_faketouch' : ev.identifier),
                x: typeof ev.pageX == 'undefined' ? ev.x : ev.pageX,
                y: typeof ev.pageY == 'undefined' ? ev.y : ev.pageY,
                t: new Date().getTime()
            }
        },

        /**
         * Reģistrējam tap logu. Piereģistrējam touch pēc tā id un piereģistrējam tā sākuma laiku
         * @param string Touch identifikators
         */
        registerTapLog: function(touch) {
            this.tapsLog[touch.identifier] = {
                touch: this.clone(touch),
                startTime: new Date().getTime(),
                endTime: undefined,
                duration: undefined,
                executed: false
            };
        },

        /**
         * Atgreģistrējam tap. Uzliekam tap end laiku pēc touch id
         * Tā lai varam pēc tam izrēķināt cik ilgs ir bijis touch
         */
        unregisterTapLog: function(identifier) {
            if (typeof this.tapsLog[identifier] != 'undefined') {
                this.registerTapEnd(this.tapsLog[identifier])
            }
        },

        clearTapLog: function() {
            this.tapsLog = {}
        },

        registerTapEnd: function(tap) {
            if (!tap.endTime) {
                tap.endTime = new Date().getTime();
                    
                // Tap ilgums
                tap.duration = tap.endTime - tap.startTime;
            }
        },

        /**
         * Atgriež pēdējo valīdo tap no tapLog
         */
        getValidTapRegistered: function() {
            var validTap = false, mthis = this;

            this.each(this.tapsLog, function(tap){
                
                if (mthis.validateTap(tap)) {
                    validTap = tap;
                }

            })

            return validTap;
        },

        validateTap: function(tap) {
            if (tap.duration > this._config.tapMinDuration && tap.duration < this._config.tapMaxDuration) {
                return true;
            }
            return false;
        },

        /**
         * Fire events attached callbacks
         */
        fire: function(eventName, args) {
            for (var i in this.events[eventName]) {
                this.events[eventName][i].apply(this, args);
            }
        },

        /**
         * Always retranslate touch move event
         * Check if swipe width or height is greater then 0
         */
        fireTouchMove: function() {
            var t = this.formatMovement();
            if (t.width > 0 || t.height > 0) {
                this.fire("touchmove", [t]);
            }
        },

        /**
         * Check if target is same as this.el or target is child of this.el
         */
        isTheElement: function(target) {
            return (target == this.el || this.isChild(target, this.el));
        },

        isChild: function(target, element) {
            var n = target.parentNode;
            while (n) {
                if (n == element) {
                    return true;
                }
                n = n.parentNode;
            }
            return false;
        },

        addEvent: function(obj, type, fn, params) {
            params = (typeof params == 'undefined' ? false : params);
            if ( obj.attachEvent ) {
                obj['e'+type+fn] = fn;
                obj[type+fn] = function(){obj['e'+type+fn](window.event)}
                obj.attachEvent('on'+type, obj[type+fn]);
            }
            else {
                obj.addEventListener(type, fn, params);
            }
        },

        removeEvent: function(obj, type, fn, params) {
            params = (typeof params == 'undefined' ? false : params);
            if ( obj.detachEvent ) {
                obj.detachEvent( 'on'+type, obj[type+fn] );
                obj[type+fn] = null;
            }
            else {
                obj.removeEventListener(type, fn, params);
            }
        },

        preventEvent: function(ev) {
            if (ev.preventDefault) {
                ev.preventDefault();
            }
            else {
                ev.returnValue = false;
            }
        },

        /**
         * Normalize event.target
         */
        eventTarget: function(ev) {
            var el;

            if (ev.target) {
                el = ev.target;
            }
            else if (ev.srcElement) {
                el = ev.srcElement
            }
            
            // Safari bug. Selected text returns text
            if (el.nodeType == 3) {
                el = el.parentNode
            }

            return el;
        },

        /**
         * Add event listener
         */
        on: function(eventName, cb) {
            if (typeof this.events[eventName] != 'undefined') {
                this.events[eventName].push(cb);
            }

            return this;
        },

        isEventsRegistered: function(eventName) {
            return (typeof this.events[eventName] != 'undefined' && this.events[eventName].length > 0);
        },

        /**
         * Set configuration parameters
         */
        config: function(config) {
            if (typeof config == 'undefined') {
                config = {};
            }

            function formatByType(value, type) {
                switch (type) {
                    case 'int': return parseInt(value, 10);
                    case 'boolean': return (value ? true : false);
                    default: return value
                }
            }
            
            function formatValue(value, config) {
                if (typeof config.multiple == 'undefined') {
                    config.multiple = false;
                }

                if (config.multiple) {
                    value = value.split(' ');
                    for (var i = 0; i < value.length; i++) {
                        value[i] = formatByType(value[i], config.type);
                    }
                }
                else {
                    value = formatByType(value, config.type)
                }

                return value;
            }

            var defConfig = {
                // Directions var būt vairāki (vertical horizontal)
                direction:  {value: ['horizontal', 'vertical'], type: 'string', multiple: true},

                minWidth: {value: false, type: 'int'},
                minHeight: {value: false, type: 'int'},
                minDuration: {value: false, type: 'int'},

                maxWidth: {value: false, type: 'int'},
                maxHeight: {value: false, type: 'int'},
                maxDuration: {value: false, type: 'int'},

                disablePinch: {value: false, type: 'boolean'},

                /**
                 * Prevent any movement. Šis notiek touchstart eventā
                 * Šis palīdz iOS gadījumā, kad neskatoties uz prevent move
                 * lapa tā pat dabū skrolēties ar elastic
                 */
                alwaysPreventTouchStart: {value: false, type: 'boolean'},

                doubletapWaitTimeout: {value: 530, type: 'int'},
                tapMaxDuration: {value: 600, type: 'int'},
                tapMinDuration: {value: 5, type: 'int'}
            }

            // Init empty config
            this._config = {};

            // Append defaults
            for (var p in defConfig) {
                this._config[p] = typeof config[p] == 'undefined' ? defConfig[p].value : formatValue(config[p], defConfig[p]);
            }
        },

        setTouchAction: function(direction) {
            var c = [];

            if (this.isDirection(direction, 'vertical')) {
                c.push('pan-x');
            }

            if (this.isDirection(direction, 'horizontal')) {
                c.push('pan-y');
            }
            
            // Pievienojam touch-action
            if (c.length > 0) {
                this.el.style.touchAction = c.join(' ');    
            }
            else {
                this.el.style.touchAction = 'none';
            }
        },

        isDirection: function(directionsArray, direction) {
            for (var i = 0; i < directionsArray.length; i++) {
                if (directionsArray[i] == direction) {
                    return true
                }
            }
            return false;
        },

        /**
         * Destroy swipe monitoring
         */
        destroy: function() {
            // Remove all event listeners
            this.handleEvents('remove');
            this.events = [];
        },

        objProps: function(obj) {
            var r = [];
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) {
                    r.push(name);
                }
            }
            return r;
        },

        map: function(obj, cb) {
            var r = [];
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) {
                    r.push(cb(obj[name], obj));
                }
            }
            return r;
        },

        each: function(obj, cb) {
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) {
                    cb(obj[name], name);
                }
            }
        },

        clone: function(obj) {
            var r = {};
            for (var name in obj) {
                if (obj.hasOwnProperty(name)) {
                    r[name] = obj[name];
                }
            }
            return r;
        }
    }

    return Swipe;
});
},{}],4:[function(require,module,exports){
var hasCssClass = require('./hasCssClass');

function addCssClass(el, className) {
    if (hasCssClass(el, className)) {
        return;
    }

    if (typeof el.classList != 'undefined') {
        el.classList.add(className);
    }
    else {
        el.className += ' '+className;
    }
}

module.exports = addCssClass
},{"./hasCssClass":15}],5:[function(require,module,exports){
var prefixableProps = ['transform'];

function addStyle(el, props) {

    props = vendorPrefix(props);

    for (var name in props) {
        if (!props.hasOwnProperty(name)) {
            continue;
        }

        el.style[name] = props[name];
    }
}

function vendorPrefix(props) {
    var r = {};

    for (var name in props) {
        if (!props.hasOwnProperty(name)) {
            continue;
        }

        r[name] = props[name];

        if (shouldPrefix(name)) {
            r[name] = props[name];
            r['-webkit-'+name] = props[name];
            r['-moz-'+name] = props[name];
            r['-ms-'+name] = props[name];
            r['-o-'+name] = props[name];
        }
    }

    return r;
}

function shouldPrefix(name) {
    return prefixableProps.indexOf(name) >= 0;
}

module.exports = addStyle
},{}],6:[function(require,module,exports){
var BodyScroll = require('./bodyScrollDisable');
var Overlay = require('./overlay');
var Manager = require('./manager');

function init() {
    BodyScroll.init();
    Overlay.init();
    Manager.init();
}

module.exports = {
    init: init,

    register: Manager.registerPanel,
    get: Manager.getPanel,
    show: Manager.showPanel,
    hide: Manager.hidePanel,

    onHide: Manager.onHide
}
},{"./bodyScrollDisable":7,"./manager":16,"./overlay":17}],7:[function(require,module,exports){
var getWindowScrollTop = require('./getWindowScrollTop');
var setWindowScrollTop = require('./setWindowScrollTop');
var addCssClass = require('./addCssClass');
var removeCssClass = require('./removeCssClass');
var addStyle = require('./addStyle');

var app, appContainer, scrollTop;

function init() {
    app = getEl('app');
    appContainer = getEl('app-w');
}

function getEl(className) {
    var r = document.getElementsByClassName(className);
    return r.length > 0 ? r[0] : null;
}

function disable() {
    // Piefiksējam scroll top
    scrollTop = getWindowScrollTop();

    addCssClass(appContainer, 'app-w--disabled');
    addStyle(app, {
        transform: 'translate(0,-'+scrollTop+'px)'
    })
}

function enable() {
    removeCssClass(appContainer, 'app-w--disabled');
    addStyle(app, {
        transform: ''
    })

    // Atjaunojam scroll top
    setWindowScrollTop(scrollTop);
}

module.exports = {
    init: init,
    disable: disable,
    enable: enable
}
},{"./addCssClass":4,"./addStyle":5,"./getWindowScrollTop":14,"./removeCssClass":20,"./setWindowScrollTop":21}],8:[function(require,module,exports){
function calcPanelXYOffsetByProgress(align, revealDirection, panelDimensions, viewportDimensions, progress) {
    if (typeof method[align+revealDirection] != 'undefined') {
        return method[align+revealDirection](panelDimensions, viewportDimensions, progress)
    }

    return {
        x: 0,
        y: 0
    }
}

/**
 * Visas dažādās align + revealDirection metodes
 */
var method = {
    leftleft: function(pd, vd, p) {
        return {
            x: -(pd.width - pd.width * p),
            y: 0
        }
    },
    
    leftright: function(pd, vd, p) {
        return {
            x: vd.width - vd.width * p,
            y: 0
        }
    },

    lefttop: function(pd, vd, p) {
        return {
            x: 0,
            y: -(pd.height - pd.height * p)
        }
    },

    leftbottom: function(pd, vd, p) {
        return {
            x: 0,
            y: vd.height - vd.height * p
        }
    },


    rightright: function(pd, vd, p) {
        return {
            x: pd.width - pd.width * p,
            y: 0
        }
    },

    rightleft: function(pd, vd, p) {
        return {
            x: -((vd.width + pd.width) - (vd.width + pd.width) * p),
            y: 0
        }
    },

    righttop: function(pd, vd, p) {
        return {
            x: 0,
            y: -(pd.height - pd.height * p)
        }
    },

    rightbottom: function(pd, vd, p) {
        return {
            x: 0,
            y: vd.height - vd.height * p
        }
    }
}

module.exports = calcPanelXYOffsetByProgress;
},{}],9:[function(require,module,exports){
function addEvent(obj, type, fn, params) {
    params = (typeof params == 'undefined' ? false : params);
    if ( obj.attachEvent ) {
        obj['e'+type+fn] = fn;
        obj[type+fn] = function(){obj['e'+type+fn](window.event)}
        obj.attachEvent('on'+type, obj[type+fn]);
    }
    else {
        obj.addEventListener(type, fn, params);
    }
}

function removeEvent(obj, type, fn, params) {
    params = (typeof params == 'undefined' ? false : params);
    if ( obj.detachEvent ) {
        obj.detachEvent( 'on'+type, obj[type+fn] );
        obj[type+fn] = null;
    }
    else {
        obj.removeEventListener(type, fn, params);
    }
}

function preventEvent(ev) {
    if (ev.preventDefault) {
        ev.preventDefault();
    }
    else {
        ev.returnValue = false;
    }
}

/**
 * Normalize event.target
 */
function eventTarget(ev) {
    var el;

    if (ev.target) {
        el = ev.target;
    }
    else if (ev.srcElement) {
        el = ev.srcElement
    }
    
    // Safari bug. Selected text returns text
    if (el.nodeType == 3) {
        el = el.parentNode
    }

    return el;
}

module.exports = {
    addEvent: addEvent,
    removeEvent: removeEvent,
    preventEvent: preventEvent,
    eventTarget: eventTarget
}
},{}],10:[function(require,module,exports){
function eventTarget(ev) {
    var el;

    if (ev.target) {
        el = ev.target;
    }
    else if (ev.srcElement) {
        el = ev.srcElement
    }
    
    // Safari bug. Selected text returns text
    if (el.nodeType == 3) {
        el = el.parentNode
    }

    return el;
}

module.exports = eventTarget
},{}],11:[function(require,module,exports){
function fireCallbacks(callbacksArray, args) {
    for (var i = 0; i < callbacksArray.length; i++) {
        callbacksArray[i].apply(this, args);
    }
}

module.exports = fireCallbacks;
},{}],12:[function(require,module,exports){
function getData(object, propName, defaultValue) {
    if (typeof object == 'undefined') {
        return defaultValue;
    }
    if (typeof object[propName] == 'undefined') {
        return defaultValue;        
    }

    return object[propName];
}

module.exports = getData;
},{}],13:[function(require,module,exports){
function getWindowDimensions() {
    var w = window,
    d = document,
    e = d.documentElement,
    g = d.getElementsByTagName('body')[0];

    return {
        width: w.innerWidth || e.clientWidth || g.clientWidth,
        height: w.innerHeight|| e.clientHeight|| g.clientHeight
    }
}

module.exports = getWindowDimensions;
},{}],14:[function(require,module,exports){
function getWindowScrollTop() {
    return window.pageYOffset || (document.documentElement || document.body.parentNode || document.body).scrollTop
}

module.exports = getWindowScrollTop

},{}],15:[function(require,module,exports){
function hasCssClass(el, className) {
    if (typeof el.classList != 'undefined') {
        return el.classList.contains(className);
    }
    else {
        return el.className.match(new RegExp('(?:^|\\s)'+className+'(?!\\S)', 'ig')) ? true : false;
    }
}

module.exports = hasCssClass;
},{}],16:[function(require,module,exports){
var Stepper = require('stepper');
var BodyScroll = require('./bodyScrollDisable');
var Overlay = require('./overlay');
var Panel = require('./panel');
var fireCallbacks = require('./fireCallbacks');
var propPushToArray = require('./propPushToArray');
var getData = require('./getData');
var validateAnimDurations = require('./validateAnimDurations');

var Step, OverlayStep, panels = {}, 
    needToShowOverlay = true, needToHideOverlay = true, 
    openPanelsCount = 0, openPanelsStack = []
    callbacks = {
        hide: {},
        show: {}
    };

function init() {
    Step = new Stepper();
    OverlayStep = new Stepper();
}

function registerPanel(name, $el, props) {
    if (typeof panels[name] != 'undefined') {
        return
    }

    panels[name] = createPanel(name, $el, props);
}

function createPanel(name, $el, props) {
    var r = new Panel(name, $el, props);
    
    setPanelEvents(r);

    return r;
}

function getPanel(name) {
    return panels[name]
}

function setPanelEvents(Panel) {
    Panel.onClose(function(){
        handlePanelHide(Panel)
    })
}

function handlePanelShow(Panel, config) {
    showPanel(Panel, config);
}

/**
 * Panel hide event
 */
function handlePanelHide(Panel, config) {
    // Ja panelim ir custom close callback, tad tam padodam iekšejo close metodi
    if (typeof callbacks.hide[Panel.name] != 'undefined') {
        fireCallbacks(callbacks.hide[Panel.name], [function(){
            hidePanel(Panel, config)
        }])
    }
    else {
        hidePanel(Panel, config)
    }
}

function panelBeforeShow(panel) {
    openPanelsCount++;
    openPanelsStack.push(panel);

    //if (openPanelsCount > 0)

    needToShowOverlay = !Overlay.isVisible();
    
    if (needToShowOverlay) {
        Overlay.beforeShow();
        BodyScroll.disable();
    }

    panel.beforeShow();
}

function panelBeforeHide(panel) {
    
    panel.beforeHide();

    needToHideOverlay = Overlay.isVisible()

    if (openPanelsCount > 1) {
        needToHideOverlay = false;
    }

    if (needToHideOverlay) {
        Overlay.beforeHide();
    }
}

function panelAfterHide(panel) {
    openPanelsCount--;
    openPanelsStack.pop();

    if (openPanelsCount > 0) {
        openPanelsStack[openPanelsStack.length-1].enable();
    }

    //if (openPanelsCount <= 0)

    if (needToHideOverlay) {
        Overlay.afterHide();
        BodyScroll.enable();
    }

    panel.afterHide();
}

function showPanel(panel, config) {

    panel.setOverrideProps(config);


    var animDurations = validateAnimDurations(panel.getProp('animDurations'));
    var showOverlay = panel.getProp('showOverlay', true);

    console.log('showPanel', animDurations);

    panel.hideOnOutsideClick = panel.getProp('hideOnOutsideClick', false);

    // Iepriekšējo paneli, ja tāds ir, disable
    if (openPanelsCount > 0) {
        openPanelsStack[openPanelsStack.length-1].disable();
    }

    panelBeforeShow(panel);

    if (showOverlay && needToShowOverlay) {

        if (animDurations.overlay <= 0) {
            Overlay.applyProgress(1)
        }
        else {
            OverlayStep.run(animDurations.overlay, [0.455, 0.03, 0.515, 0.955],
                function(p){
                    Overlay.applyProgress(p)
                }
            )    
        }
        
    }

    if (animDurations.panel <= 0) {
        panel.applyProgress(1);
        if (panel.showPanelDone) {
            panel.showPanelDone()
        }

        panel.setOverrideProps(null);
    }
    else {
        setTimeout(function(){
            Step.run(animDurations.panel, [0.455, 0.03, 0.515, 0.955],
                function(p){
                    panel.applyProgress(p)
                }, 
                function(){
                    if (panel.showPanelDone) {
                        panel.showPanelDone()
                    }

                    panel.setOverrideProps(null);
                }
            )
        }, 140)
    }
    
}

function hidePanel(panel, config) {
    panel.setOverrideProps(config);

    var animDurations = validateAnimDurations(panel.getProp('animDurations'));

    panelBeforeHide(panel);

    if (needToHideOverlay) {
        if (animDurations.overlay <= 0) {
            Overlay.applyProgress(0)
        }
        else {
            OverlayStep.run(animDurations.overlay, [0.455, 0.03, 0.515, 0.955],
                function(p){

                    if (Overlay.getProgress() >= (1-p)) {
                        Overlay.applyProgress(1-p)
                    }
                }
            )
        }        
    }

    if (animDurations.panel <= 0) {
        panel.applyProgress(0);
        panelAfterHide(panel);

        panel.setOverrideProps(null);
    }
    else {
        Step.run(animDurations.panel, [0.455, 0.03, 0.515, 0.955], 
            function(p){
                panel.applyProgress(1-p)
            }, 
            function(){
                panelAfterHide(panel);

                panel.setOverrideProps(null);
            }
        )    
    }
    
}

function hidePanelImediately(panel) {
    hidePanel(panel, {
        overlay: 0,
        panel: 0
    })
}

function hideAll(){
    if (openPanelsCount > 0) {

        var r = [];
        for (var i = 0; i < openPanelsStack.length; i++) {
            r.push(openPanelsStack[i]);
        }

        for (var i = 0; i < r.length-1; i++) {
            hidePanelImediately(r[i]);
        }

        hidePanel(r[r.length-1]);
    }
}

module.exports = {
    init: init,

    registerPanel: registerPanel,
    getPanel: getPanel,

    showPanel: function(panelName, config) {
        handlePanelShow(getPanel(panelName), config)
    },
    hidePanel: function(panelName, props) {
        handlePanelHide(getPanel(panelName), props)
    },

    hideAll: hideAll,

    onHide: function(panelName, cb) {
        callbacks.hide = propPushToArray(callbacks.hide, panelName, cb)
    }
}

},{"./bodyScrollDisable":7,"./fireCallbacks":11,"./getData":12,"./overlay":17,"./panel":18,"./propPushToArray":19,"./validateAnimDurations":22,"stepper":2}],17:[function(require,module,exports){
var addCssClass = require('./addCssClass');
var removeCssClass = require('./removeCssClass');

var el, visible = false, currentProgress;

function init() {
    createEl();
}

/**
 * Izveidojam overlay elementu un ieliekam body tagā
 */
function createEl() {
    el = document.createElement('div');
    el.className = 'overlay';
    document.getElementsByTagName('body')[0].appendChild(el)
}

function beforeShow() {
    visible = true;

    applyProgress(0)
    addCssClass(el, 'overlay--visible-step1');
}

function beforeHide() {
    visible = false;
}

function afterHide() {
    removeCssClass(el, 'overlay--visible-step1');
}

function applyProgress(p) {
    currentProgress = p;
    el.style.opacity = p;
}

function isVisible() {
    return visible;
}

function onClick(cb) {
    onClickCallbacks.push(cb);
}

module.exports = {
    init: init,
    beforeShow: beforeShow,
    beforeHide: beforeHide,
    afterHide: afterHide,
    applyProgress: applyProgress,
    isVisible: isVisible,
    getProgress: function() {
        return currentProgress
    }
}
},{"./addCssClass":4,"./removeCssClass":20}],18:[function(require,module,exports){
var Swipe = require('swipe');
var addCssClass = require('./addCssClass');
var hasCssClass = require('./hasCssClass');
var removeCssClass = require('./removeCssClass');
var addStyle = require('./addStyle');
var getWindowDimensions = require('./getWindowDimensions');
var calcPanelXYOffsetByProgress = require('./calcPanelXYOffsetByProgress');
var domEvents = require('./domEvents');
var eventTarget = require('./eventTarget');

function panel(name, $el, props) {

    this.closeCb = undefined;
    this.beforeShowCb = undefined;

    this.name = name;
    this.props = props;
    /**
     * Override props. 
     * Šos var uzstādīt veicot show vai hide, tad var padots
     * savādākus props.
     * Kad nolasīs props, tad kā prioritāte būs props2
     */
    this.props2 = undefined;

    this.$el = $el;
    this.el = this.prepareEl($el.get(0));

    /**
     * Ja noklikšķināts ārpus body, tad aizvērt
     * Vizuāli it kā uz overlay noklikšķināts
     */
    this.hideOnOutsideClick = false;

    /**
     * Paneļa platums. Šis tiek ņemts no props.width
     * Ar šo mainīgo width tiek iekešots un tiek ielasīts
     * tikai vienu reizi beforeShow eventā
     */
    this.panelDimensions = { width: 0, height: 0 }
    this.panelAlign = 'right';
    this.revealDirection = 'right';
    this.windowDimensions = { width: 0, height: 0 }

    /**
     * Animējamie elementi
     */
    this.animableElements = {
        'bg': $el.find('.modal-panel__bg').get(0),
        'header': $el.find('.modal-panel__header').get(0),
        'footer': $el.find('.modal-panel__footer').get(0),
        'content': $el.find('.modal-panel__content').get(0)
    }

    //this.swipe = new Swipe(this.el, {'direction': 'horizontal vertical'});

    this.setEvents();
}

panel.prototype = {
    setEvents: function() {
        var mthis = this;

        // this.swipe.on('start', function(touch){
        //     mthis.handleTouchStart(touch)
        // }) 

        // domEvents.addEvent(this.el, 'touchstart', function(ev){
        //     mthis.handleTouchStart(ev)
        // })

        domEvents.addEvent(this.el, 'click', function(ev){
            var el = eventTarget(ev);
            var closePanel = false;
            
            // Pats panelis, reaģējam uz ārpus paneļa body click
            if (el == mthis.el) {
                if (mthis.hideOnOutsideClick) {
                    closePanel = true;
                }
            }
            else if (hasCssClass(el, 'modal-panel__close')) {
                /**
                 * Reaģējam uz panelī definēto close pogu
                 * closeCb nāk no panelsManager, kura šādā 
                 * veidā pateiksim, ka ir jāaizveras
                 */
                closePanel = true;
            }

            if (closePanel) {
                ev.preventDefault();

                if (mthis.closeCb) {
                    mthis.closeCb();
                }
            }
        })
    },

    prepareEl: function(el) {

        // Default align: right
        addCssClass(el, 'modal-panel--'+this.getAlign())

        return el;
    },

    
    /**
     * @todo Jāpārdomā vai šo tiešām vajag, jo šis pārtrauc onClick eventu
     */
    // handleTouchStart: function(ev) {
    //     /**
    //      * Mobile safari:
    //      * Ja panel ir mazāks par windowHeight, tad jānovērš overscroll
    //      * Reaģējam tikai uz this.el
    //      */
    //     if (this.panelDimensions.height < this.windowDimensions.height) {
    //         if (domEvents.eventTarget(ev) == this.el) {
    //             domEvents.preventEvent(ev);
    //         }
    //     }
    // },

    setOverrideProps: function(props) {
        this.props2 = props;
    },

    getProp: function(name, defaultValue) {
        // Override props. Šos skatamies pirmos
        if (this.props2) {
            if (typeof this.props2[name] != 'undefined') {
                return this.props2[name];
            }
        }       

        // Default props, kuri uzlikti konstruktora laikā
        if (typeof this.props[name] != 'undefined') {
            return this.props[name]
        }

        return defaultValue
    },

    /**
     * Paneļa novietojums
     */
    getAlign: function() {
        return this.getProp('align', 'right');
    },

    /**
     * Virziens, no kura panelis tiek iebīdīts ekrānā
     */
    getRevealDirection: function() {
        return this.getProp('revealDirection', this.getAlign());
    },

    /**
     * Get width ir konfigurējams no props
     */
    getWidth: function(viewportDimensions) {
        var width = this.getProp('width', 320);

        switch (typeof width) {
            // Width var nodefinēt kā funkciju
            case 'function':
                return width(viewportDimensions);
            default:
                return width;
        }
    },

    /**
     * Get width ir konfigurējams no props
     */
    getHeight: function(viewportDimensions) {
        var height = this.getProp('height', viewportDimensions.height);

        switch (typeof height) {
            // Width var nodefinēt kā funkciju
            case 'function':
                return height(viewportDimensions);
            default:
                return height;
        }
    },

    setAnimableElementsStyle: function(cssProps) {
        for (var n in this.animableElements) {
            if (!this.animableElements.hasOwnProperty(n)) {
                continue;
            }
            
            if (!this.animableElements[n]) {
                continue;
            }
            
            addStyle(this.animableElements[n], cssProps);
        }
    },

    /**
     * Interfeiss priekš īstās applyProgress metodes
     * _applyProgress tiek nodefinēts konstruktorā
     */
    applyProgress: function(progress) {
        var mthis = this;

        // Ja ir custom applyProgress metode
        if (this.getProp('applyProgress')) {
            this.getProp('applyProgress')(this, progress, function(progress){
                mthis.applyProgressDefault(progress)
            })
        }
        else {
            this.applyProgressDefault(progress)
        }
    },

    /**
     * applyProgress ir iespēja overraidot. 
     * Šī ir default applyProgress funkcionalitāte
     * @param number Progress: 0 - sākuma stāvoklis (aizvērts), 1 - pilnībā atvērts
     */
    applyProgressDefault: function(progress) {
        this.setXYOffset(
            calcPanelXYOffsetByProgress(
                this.panelAlign, 
                this.revealDirection,
                this.panelDimensions,
                this.windowDimensions,
                progress
            )
        );
    },

    setXYOffset: function(offset) {
        this.setAnimableElementsStyle({
            transform: 'translate3d('+offset.x+'px,'+offset.y+'px,0)'
        })
    },

    setWidth: function(width) {
        this.setAnimableElementsStyle({
            width: width+'px'
        });
    },

    setHeight: function(height) {
        /**
         * Mobile safari: jāuzliek windowHeight, lai neparādītos bottom pogas
         * Visi elementi ir fixed, šis būs tas, kas saglabās windowHeight
         * @todo Te vēl vajadzētu uzlikt touchstart eventu, lai varētu atcelt
         * overscroll
         */
        addStyle(this.el, {height: this.windowDimensions.height+'px'})

        /**
         * Special case, kad height ir tāds pats kā viewportHeight
         * šajā gadījumā vajag lai background ir lielāks par viewport, 
         * lai scrollējot uz mobile safari/chrome nebūtu raustišanās,
         * kad parādās un pazūd bottom menu (kas izraisa ekrāna paaugstināšanos)
         */
        if (height >= this.windowDimensions.height) {
            addStyle(this.animableElements.bg, {height: '120%'})
        }
        else {
            addStyle(this.animableElements.bg, {height: height+'px'})
        }
    },

    beforeShow: function() {
        this.windowDimensions = getWindowDimensions();
        this.panelDimensions = {
            width: this.getWidth(this.windowDimensions),
            height: this.getHeight(this.windowDimensions)
        };
        this.panelAlign = this.getAlign();
        this.revealDirection = this.getRevealDirection();
        

        this.setWidth(this.panelDimensions.width);
        this.setHeight(this.panelDimensions.height);
        this.applyProgress(0);

        addCssClass(this.el, 'modal-panel--visible');

        /**
         * iOS fix, ja neuzliek transform, tad skrollējot raustīsies fixed header
         */
        addStyle(this.el, {transform: 'translate3d(0,0,0)'});

        if (this.beforeShowCb) {
            this.beforeShowCb();
        }
    },

    showPanelDone: function() {
        addCssClass(this.el, 'modal-panel--ready');

        /**
         * Jānovāc transform, lai uz iOS 12 
         * scrollējot neraustītos fixed header
         */
        this.setAnimableElementsStyle({
            transform: ''
        })


        /**
         * iOS fix, ja neuzliek transform, tad skrollējot raustīsies fixed header
         * Kad animācija beigusies, tad ņemam nost, lai nebojā fixed header palikšanu
         * uz vietas, kad notiek scrollēšana
         * Ja parent elementam ir uzlikts transform, tad child position:fixed elementi
         * ir relatīvi pret parent nevis document
         */
        addStyle(this.el, {transform: ''});
    },

    beforeHide: function() {
        removeCssClass(this.el, 'modal-panel--ready');
    },

    afterHide: function() {
        removeCssClass(this.el, 'modal-panel--visible');
    },

    disable: function() {
        addCssClass(this.el, 'modal-panel--disabled');
    },

    enable: function() {
        removeCssClass(this.el, 'modal-panel--disabled');
    },

    onClose: function(cb) {
        this.closeCb = cb
    },

    onBeforeShow: function(cb) {
        this.beforeShowCb = cb;
    }
}

module.exports = panel
},{"./addCssClass":4,"./addStyle":5,"./calcPanelXYOffsetByProgress":8,"./domEvents":9,"./eventTarget":10,"./getWindowDimensions":13,"./hasCssClass":15,"./removeCssClass":20,"swipe":3}],19:[function(require,module,exports){
function propPushToArray(target, propName, value) {
    if (typeof target[propName] == 'undefined') {
        target[propName] = [];
    }
    target[propName].push(value);

    return target;
}

module.exports = propPushToArray
},{}],20:[function(require,module,exports){
function removeCssClass(el, className) {
    if (typeof el.classList != 'undefined') {
        el.classList.remove(className);
    }
    else {
        el.className = el.className.replace(new RegExp('(?:^|\\s)'+className+'(?!\\S)', 'ig'), '');
    }
}

module.exports = removeCssClass
},{}],21:[function(require,module,exports){
function setWindowScrollTop(top) {
    window.scrollTo(0, top);
}

module.exports = setWindowScrollTop
},{}],22:[function(require,module,exports){
function validateAnimDurations(d) {
    if (typeof d == 'undefined') {
        d = {};
    }

    if (typeof d.overlay == 'undefined') {
        d.overlay = 0;
    }

    if (typeof d.panel == 'undefined') {
        d.panel = 0;
    }

    return d;
}

module.exports = validateAnimDurations
},{}]},{},[6])(6)
});
