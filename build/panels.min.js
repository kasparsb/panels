(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}(g.webit || (g.webit = {})).panels = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
var b = function(p1x, p1y, p2x, p2y) {
    // Calculate the polynomial coefficients, implicit first and last control points are (0,0) and (1,1).
    var cx = 3.0 * p1x;
    var bx = 3.0 * (p2x - p1x) - cx;
    var ax = 1.0 - cx -bx;
         
    var cy = 3.0 * p1y;
    var by = 3.0 * (p2y - p1y) - cy;
    var ay = 1.0 - cy - by;

    var epsilon = 0.00001;

    function sampleCurveDerivativeX(t) {
        return (3.0 * ax * t + 2.0 * bx) * t + cx;
    }

    function sampleCurveX(t) {
        // `ax t^3 + bx t^2 + cx t' expanded using Horner's rule.
        return ((ax * t + bx) * t + cx) * t;
    }

    function sampleCurveY(t) {
        return ((ay * t + by) * t + cy) * t;
    }

    // Given an x value, find a parametric value it came from.
    function solveCurveX(x)
    {
        var t0, t1, t2, x2, d2, i;

        // First try a few iterations of Newton's method -- normally very fast.
        for (t2 = x, i = 0; i < 8; i++) {
            x2 = sampleCurveX(t2) - x;
            if (Math.abs(x2) < epsilon) {
                return t2;
            }
            d2 = sampleCurveDerivativeX(t2);
            if (Math.abs(d2) < 1e-6) {
                break;
            }
            t2 = t2 - x2 / d2;
        }

        // Fall back to the bisection method for reliability.
        t0 = 0.0;
        t1 = 1.0;
        t2 = x;

        if (t2 < t0) {
            return t0;
        }
        if (t2 > t1) {
            return t1;
        }

        while (t0 < t1) {
            x2 = sampleCurveX(t2);
            if (Math.abs(x2 - x) < epsilon) {
                return t2;
            }
            if (x > x2) {
                t0 = t2;
            }
            else {
                t1 = t2;
            }
            t2 = (t1 - t0) * .5 + t0;
        }

        // Failure.
        return t2;
    }

    this.get = function(x) {
        return sampleCurveY(solveCurveX(x));
    }
}

module.exports = b;
},{}],2:[function(require,module,exports){
//var Bezier = require('./bezier1.js');
var Bezier = require('./bezier2.js');

var Stepper = function() {
    this.defaultBezierCurve = [0,0,1,1];
    this.precision = 10000000;
    this.progress = 0;
    this.current = 0;
    this.requestId = 0;
    this.inProgress = false;
}

Stepper.prototype = {
    run: function(duration, bezierCurve, stepCb, doneCb, forceStopCb) {
        this.stepCallback = stepCb;
        this.doneCallback = doneCb;
        this.forceStopCallback = forceStopCb;

        this.easing = this.getEasing(bezierCurve);

        this.duration = isNaN(duration) ? 0 : duration;
        this.current = 0;

        this.start();
        this.step();
    },

    /**
     * Run from given progress
     */
    runFrom: function(progress, duration, bezierCurve, stepCb, doneCb) {
        this.stepCallback = stepCb;
        this.doneCallback = doneCb

        this.easing = this.getEasing(bezierCurve);

        /**
         * Šeit ir svarīgs moments
         * Padotais progress ir tāds, kādu gribam
         * bet easing aprēķinātais progress esošajā progress ir savādāk, jo 
         * tas ir curve un tas nav lineārs
         * Tāpēc šeit atrodam kādam ir jābūt progresam pēc easing
         */
        progress = this.findStartProgress(progress, 0.1, 0, 1);
        
        this.duration = duration;

        this.startTime = +new Date();
        // Simulējam startTime, tā lai tas būtu sācies pirms norādītā progress
        this.startTime -= (duration * progress);
        // Turpinām no padotā progress
        this.progress = progress;

        this.inProgress = true;


        this.step();
    },

    /**
     * Meklējam kādam ir jābūt progress, lai pēc easing.get tas būt tāds pats kā progress
     */
    findStartProgress: function(progress, step, from, to, inceptionLevel) {

        if (typeof inceptionLevel == 'undefined') {
            inceptionLevel = 0;
        }
        
        var d = from, prevR = 0, prevD;

        while (d < to) {
            // Lai ir lielāka precizītāte
            if (inceptionLevel++ > 40) {
                return d;
            }

            r = this.easing.get(d);

            if (Math.round(progress*this.precision) == Math.round(r*this.precision)) {
                return d;
            }

            if (this.isBetween(progress, prevR, r)) {
                return this.findStartProgress(progress, step/10, prevD, d, inceptionLevel);
            }

            prevD = d;
            prevR = r;
            d += step;
        }

        return d;
    },

    /**
     * Is a between x1 and x2
     */
    isBetween: function(a, x1, x2) {
        if (x2 > x1) {
            return a > x1 && a < x2;
        }
        return a > x2 && a < x1;
    },

    isRunning: function() {
        return this.inProgress;
    },

    /**
     * Piefiksējam sākuma laiku
     */
    start: function() {
        this.inProgress = true;
        this.startTime = +new Date();
        this.progress = 0;
    },

    /**
     * Pārtraucam stepping
     */
    stop: function() {
        cancelAnimationFrame(this.requestId);
        this.done();
    },

    /**
     * Pārtraucam animāciju un neizpildām done callback
     */
    forceStop: function() {
        cancelAnimationFrame(this.requestId);
        this.inProgress = false;
        if (this.forceStopCallback) {
            this.forceStopCallback();
        }
    },

    done: function() {
        this.inProgress = false;
        if (this.doneCallback) {
            this.doneCallback();
        }
    },

    step: function() {
        var mthis = this;


        // if (this._prevTime) {
        //     log('stepper.step', Math.round(window.performance.now() - this._prevTime));
        // }
        // this._prevTime = window.performance.now();


        mthis.trackProgress();

        if (this.current < this.startTime + this.duration) {

            this.stepCallback(this.progress);

            this.requestId = requestAnimationFrame(function(){
                mthis.step()
            });
        }
        else {
            this.stepCallback(1);

            this.done();
        }
    },

    trackProgress: function() {
        // Current time
        this.current = +new Date();

        var delta = this.current - this.startTime;

        // Animation progress in precents
        this.progress = this.easing.get(delta / this.duration);

        //this.progress = Math.round(this.progress*this.precision)/this.precision;
    },

    getEasing: function(bezierCurve) {
        if (!(bezierCurve && bezierCurve.length && bezierCurve.length == 4)) {
            bezierCurve = this.defaultBezierCurve;
        }
        return new Bezier(bezierCurve[0], bezierCurve[1], bezierCurve[2], bezierCurve[3]);
    }
}

module.exports = Stepper;
},{"./bezier2.js":1}],3:[function(require,module,exports){
var hasCssClass = require('./hasCssClass');

function addCssClass(el, className) {
    if (hasCssClass(el, className)) {
        return;
    }

    if (typeof el.classList != 'undefined') {
        el.classList.add(className);
    }
    else {
        el.className += ' '+className;
    }
}

module.exports = addCssClass
},{"./hasCssClass":8}],4:[function(require,module,exports){
var prefixableProps = ['transform'];

function addStyle(el, props) {

    props = vendorPrefix(props);

    for (var name in props) {
        if (!props.hasOwnProperty(name)) {
            continue;
        }

        el.style[name] = props[name];
    }
}

function vendorPrefix(props) {
    var r = {};

    for (var name in props) {
        if (!props.hasOwnProperty(name)) {
            continue;
        }

        r[name] = props[name];

        if (shouldPrefix(name)) {
            r[name] = props[name];
            r['-webkit-'+name] = props[name];
            r['-moz-'+name] = props[name];
            r['-ms-'+name] = props[name];
            r['-o-'+name] = props[name];
        }
    }

    return r;
}

function shouldPrefix(name) {
    return prefixableProps.indexOf(name) >= 0;
}

module.exports = addStyle
},{}],5:[function(require,module,exports){
var BodyScroll = require('./bodyScrollDisable');
var Overlay = require('./overlay');
var Manager = require('./manager');

BodyScroll.init();
Overlay.init();
Manager.init();

module.exports = {
    register: Manager.registerPanel,
    get: Manager.getPanel,
    show: Manager.showPanel,
    hide: Manager.hidePanel
}
},{"./bodyScrollDisable":6,"./manager":9,"./overlay":10}],6:[function(require,module,exports){
var getWindowScrollTop = require('./getWindowScrollTop');
var setWindowScrollTop = require('./setWindowScrollTop');
var addCssClass = require('./addCssClass');
var removeCssClass = require('./removeCssClass');
var addStyle = require('./addStyle');

var app, appContainer, scrollTop;

function init() {
    app = getEl('app');
    appContainer = getEl('app-w');
}

function getEl(className) {
    var r = document.getElementsByClassName(className);
    return r.length > 0 ? r[0] : null;
}

function disable() {
    // Piefiksējam scroll top
    scrollTop = getWindowScrollTop();

    addCssClass(appContainer, 'app-w--disabled');
    addStyle(app, {
        transform: 'translate(0,-'+scrollTop+'px)'
    })
}

function enable() {
    removeCssClass(appContainer, 'app-w--disabled');
    addStyle(app, {
        transform: ''
    })

    // Atjaunojam scroll top
    setWindowScrollTop(scrollTop);
}

module.exports = {
    init: init,
    disable: disable,
    enable: enable
}
},{"./addCssClass":3,"./addStyle":4,"./getWindowScrollTop":7,"./removeCssClass":12,"./setWindowScrollTop":13}],7:[function(require,module,exports){
function getWindowScrollTop() {
    return window.pageYOffset || (document.documentElement || document.body.parentNode || document.body).scrollTop
}

module.exports = getWindowScrollTop

},{}],8:[function(require,module,exports){
function hasCssClass(el, className) {
    if (typeof el.classList != 'undefined') {
        el.classList.contains(className);
    }
    else {
        return el.className.match(new RegExp('(?:^|\\s)'+className+'(?!\\S)', 'ig')) ? true : false;
    }
}

module.exports = hasCssClass;
},{}],9:[function(require,module,exports){
var Stepper = require('stepper');
var BodyScroll = require('./bodyScrollDisable');
var Overlay = require('./overlay');
var Panel = require('./panel');

var Step, OverlayStep, panels = {}, 
    needToShowOverlay = true, needToHideOverlay = true, 
    openPanelsCount = 0, openPanelsStack = [];

function init() {
    Step = new Stepper();
    OverlayStep = new Stepper();
}

function registerPanel(name, $el, props) {
    if (typeof panels[name] != 'undefined') {
        return
    }

    panels[name] = createPanel(name, $el, props);
}

function createPanel(name, $el, props) {
    var r = new Panel(name, $el, props);
    
    setPanelEvents(r);

    return r;
}

function getPanel(name) {
    return panels[name]
}

function setPanelEvents(Panel) {
    Panel.onClose(function(){
        hidePanel(Panel)
    })
}


function panelBeforeShow(panel) {
    openPanelsCount++;
    openPanelsStack.push(panel);

    //if (openPanelsCount > 0)

    needToShowOverlay = !Overlay.isVisible();
    
    if (needToShowOverlay) {
        Overlay.beforeShow();
        BodyScroll.disable();
    }

    panel.beforeShow();
}

function panelBeforeHide(panel) {
    
    panel.beforeHide();

    needToHideOverlay = Overlay.isVisible()

    if (openPanelsCount > 1) {
        needToHideOverlay = false;
    }

    if (needToHideOverlay) {
        Overlay.beforeHide();
    }
}

function panelAfterHide(panel) {
    openPanelsCount--;
    openPanelsStack.pop();

    if (openPanelsCount > 0) {
        openPanelsStack[openPanelsStack.length-1].enable();
    }

    //if (openPanelsCount <= 0)

    if (needToHideOverlay) {
        Overlay.afterHide();
        BodyScroll.enable();
    }

    panel.afterHide();
}

function showPanel(panel, withoutAnimation, animDurations) {

    if (typeof panel != 'object') {
        panel = getPanel(panel);
    }

    if (typeof withoutAnimation == 'undefined') {
        withoutAnimation = false;
    }

    if (typeof animDurations == 'undefined') {
        animDurations = {
            overlay: 500,
            panel: 500
        }
    }

    // Iepriekšējo paneli, ja tāds ir, disable
    if (openPanelsCount > 0) {
        openPanelsStack[openPanelsStack.length-1].disable();
    }

    panelBeforeShow(panel);

    if (needToShowOverlay) {

        if (withoutAnimation) {
            Overlay.applyProgress(1)
        }
        else {
            OverlayStep.run(animDurations.overlay, [0.455, 0.03, 0.515, 0.955],
                function(p){
                    Overlay.applyProgress(p)
                }
            )    
        }
        
    }

    if (withoutAnimation) {
        panel.applyProgress(1);
        if (panel.showPanelDone) {
            panel.showPanelDone()
        }
    }
    else {
        setTimeout(function(){
            Step.run(animDurations.panel, [0.455, 0.03, 0.515, 0.955],
                function(p){
                    panel.applyProgress(p)
                }, 
                function(){
                    if (panel.showPanelDone) {
                        panel.showPanelDone()
                    }
                }
            )
        }, 140)
    }
    
}

function hidePanel(panel, withoutAnimation, animDurations) {
    if (typeof panel != 'object') {
        panel = getPanel(panel);
    }

    if (typeof withoutAnimation == 'undefined') {
        withoutAnimation = false;
    }

    if (typeof animDurations == 'undefined') {
        animDurations = {
            overlay: 500,
            panel: 500
        }
    }

    panelBeforeHide(panel);

    if (needToHideOverlay) {
        if (withoutAnimation) {
            Overlay.applyProgress(0)
        }
        else {
            OverlayStep.run(animDurations.overlay, [0.455, 0.03, 0.515, 0.955],
                function(p){
                    Overlay.applyProgress(1-p)
                }
            )
        }
        
    }

    if (withoutAnimation) {
        panel.applyProgress(0);
        panelAfterHide(panel);
    }
    else {
        Step.run(animDurations.panel, [0.455, 0.03, 0.515, 0.955], 
            function(p){
                panel.applyProgress(1-p)
            }, 
            function(){
                panelAfterHide(panel);
            }
        )    
    }
    
}

function hidePanelImediately(panel) {
    hidePanel(panel, true)
}

function hideAll(){
    if (openPanelsCount > 0) {

        var r = [];
        for (var i = 0; i < openPanelsStack.length; i++) {
            r.push(openPanelsStack[i]);
        }

        for (var i = 0; i < r.length-1; i++) {
            hidePanelImediately(r[i]);
        }

        hidePanel(r[r.length-1]);
    }
}

module.exports = {
    init: init,

    registerPanel: registerPanel,
    getPanel: getPanel,
    showPanel: showPanel,
    hidePanel: hidePanel,

    hideAll: hideAll
}

},{"./bodyScrollDisable":6,"./overlay":10,"./panel":11,"stepper":2}],10:[function(require,module,exports){
var addCssClass = require('./addCssClass');
var removeCssClass = require('./removeCssClass');

var el, visible = false;

function init() {
    createEl();
}

/**
 * Izveidojam overlay elementu un ieliekam body tagā
 */
function createEl() {
    el = document.createElement('div');
    el.className = 'overlay';
    document.getElementsByTagName('body')[0].appendChild(el)
}

function beforeShow() {
    visible = true;

    applyProgress(0)
    addCssClass(el, 'overlay--visible-step1');
}

function beforeHide() {
    visible = false;
}

function afterHide() {
    removeCssClass(el, 'overlay--visible-step1');
}

function applyProgress(p) {
    el.style.opacity = p;
}

function isVisible() {
    return visible;
}

module.exports = {
    init: init,
    beforeShow: beforeShow,
    beforeHide: beforeHide,
    afterHide: afterHide,
    applyProgress: applyProgress,
    isVisible: isVisible
}
},{"./addCssClass":3,"./removeCssClass":12}],11:[function(require,module,exports){
var addCssClass = require('./addCssClass');
var removeCssClass = require('./removeCssClass');
var addStyle = require('./addStyle');

function panel(name, $el, props) {

    this.closeCb = undefined;
    this.beforeShowCb = undefined;

    this.name = name;
    this.props = props;

    this.el = this.prepareEl($el.get(0));

    /**
     * Paneļa platums. Šis tiek ņemts no props.width
     * Ar šo mainīgo width tiek iekešots un tiek ielasīts
     * tikai vienu reizi beforeShow eventā
     */
    this.panelWidth = 0;
    this.panelAlign = 'right'

    /**
     * Animējamie elementi
     */
    this.animableElements = {
        'bg': $el.find('.modal-panel__bg').get(0),
        'header': $el.find('.modal-panel__header').get(0),
        'footer': $el.find('.modal-panel__footer').get(0),
        'content': $el.find('.modal-panel__content').get(0)
    }

    this.setEvents();

    // Overraidojama applyProgress metode
    this._applyProgress = this.getProp('applyProgress', this.defaultApplyProgress)
}

panel.prototype = {
    setEvents: function() {
        var mthis = this;

        /**
         * Reaģējam uz panelī definēto close pogu
         * closeCb nāk no panelsManager, kura šādā 
         * veidā pateiksim, ka ir jāaizveras
         */
        $(this.el).on('click', '.modal-panel__close', function(ev){
            ev.preventDefault();

            
            if (mthis.closeCb) {
                mthis.closeCb();    
            }
        })
    },

    prepareEl: function(el) {

        // Default align: right
        addCssClass(el, 'modal-panel--'+this.getAlign())

        return el;
    },

    getProp: function(name, defaultValue) {
        if (typeof this.props[name] == 'undefined') {
            return defaultValue
        }

        return this.props[name]
    },

    getAlign: function() {
        return this.getProp('align', 'right');
    },

    /**
     * Get width ir konfigurējams no props
     */
    getWidth: function() {
        var width = this.getProp('width', 320);

        switch (typeof width) {
            // Width var nodefinēt kā funkciju
            case 'function':
                return this.props.width();
            default:
                return this.props.width;
        }
    },

    setAnimableElementsStyle: function(cssProps) {
        for (var n in this.animableElements) {
            if (!this.animableElements.hasOwnProperty(n)) {
                continue;
            }
            
            if (!this.animableElements[n]) {
                continue;
            }
            
            addStyle(this.animableElements[n], cssProps);
        }
    },

    /**
     * Interfeiss priekš īstās applyProgress metodes
     * _applyProgress tiek nodefinēts konstruktorā
     */
    applyProgress: function(progress) {
        this._applyProgress(this, progress)
    },

    /**
     * applyProgress ir iespēja overraidot. 
     * Šī ir default applyProgress funkcionalitāte
     * @param object Panel instance. Šajā gadījumā tas ir this
     * bet, lai būtu vieglāk saprast kā overraidot, tad šeit
     * tiek padots panel, tā pat kā custom applyProgress gadījumā
     * @param number Progress: 0 - sākuma stāvoklis (aizvērts), 1 - pilnībā atvērts
     */
    defaultApplyProgress: function(panel, progress) {
        panel.setXoffset(
            this.calcXoffsetByProgress(
                panel.panelAlign, 
                panel.panelWidth, 
                progress
            )
        );
    },

    calcXoffsetByProgress: function(align, width, progress) {
        switch (align) {
            case 'left':
                return -(width - width * progress);
                break;
            default:
                return width - width * progress;
                break;
        }
    },

    setXoffset: function(x) {
        this.setAnimableElementsStyle({
            transform: 'translate3d('+x+'px,0,0)'
        })
    },

    setWidth: function(width) {
        this.setAnimableElementsStyle({
            width: width+'px'
        });
    },

    beforeShow: function() {
        this.panelWidth = this.getWidth();
        this.panelAlign = this.getAlign();

        this.setWidth(this.panelWidth);
        this.applyProgress(0);

        addCssClass(this.el, 'modal-panel--visible');

        /**
         * iOS fix, ja neuzliek transform, tad skrollējot raustīsies fixed header
         */
        addStyle(this.el, {transform: 'translate3d(0,0,0)'});

        if (this.beforeShowCb) {
            this.beforeShowCb();
        }
    },

    showPanelDone: function() {
        addCssClass(this.el, 'modal-panel--ready');

        /**
         * Jānovāc transform, lai uz iOS 12 
         * scrollējot neraustītos fixed header
         */
        this.setAnimableElementsStyle({
            transform: ''
        })


        /**
         * iOS fix, ja neuzliek transform, tad skrollējot raustīsies fixed header
         * Kad animācija beigusies, tad ņemam nost, lai nebojā fixed header palikšanu
         * uz vietas, kad notiek scrollēšana
         * Ja parent elementam ir uzlikts transform, tad child position:fixed elementi
         * ir relatīvi pret parent nevis document
         */
        addStyle(this.el, {transform: ''});
    },

    beforeHide: function() {
        removeCssClass(this.el, 'modal-panel--ready');
    },

    afterHide: function() {
        removeCssClass(this.el, 'modal-panel--visible');
    },

    disable: function() {
        addCssClass(this.el, 'modal-panel--disabled');
    },

    enable: function() {
        removeCssClass(this.el, 'modal-panel--disabled');
    },

    onClose: function(cb) {
        this.closeCb = cb
    },

    onBeforeShow: function(cb) {
        this.beforeShowCb = cb;
    }
}

module.exports = panel
},{"./addCssClass":3,"./addStyle":4,"./removeCssClass":12}],12:[function(require,module,exports){
function removeCssClass(el, className) {
    if (typeof el.classList != 'undefined') {
        el.classList.remove(className);
    }
    else {
        el.className = el.className.replace(new RegExp('(?:^|\\s)'+className+'(?!\\S)', 'ig'), '');
    }
}

module.exports = removeCssClass
},{}],13:[function(require,module,exports){
function setWindowScrollTop(top) {
    window.scrollTo(0, top);
}

module.exports = setWindowScrollTop
},{}]},{},[5])(5)
});
